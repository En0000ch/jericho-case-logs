<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mediBot Scroll Test</title>

  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #0b0b0f; color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow-x: hidden;
    }
    #wrap { height: 300vh; }

    model-viewer {
      position: fixed;
      inset: 0;
      display: block;
      width: 100vw;
      height: 100vh;
      min-width: 100vw;
      min-height: 100vh;
      background: transparent;
    }

    #hud {
      position: fixed;
      top: 12px; left: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.55);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      font-size: 13px;
      line-height: 1.35;
      max-width: 420px;
    }
    code { color: #9ad; }
    a { color: #9ad; }
  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="hud">
    <div><strong>Scroll</strong> to scrub animation time.</div>
    <div>Model: <code>mediBot.glb</code></div>
    <div id="info">Loading…</div>
    <div><a href="./viewer.html" target="_blank">Reload viewer</a></div>
  </div>

  <model-viewer style="outline:4px solid red" 
    id="mv"
    src="./mediBot.glb"
    camera-controls
    autoplay
    interaction-prompt="none"
    loading="eager"
    reveal="auto"
    exposure="1.0"
    shadow-intensity="1">
  </model-viewer>

  <script>
  const mv = document.getElementById('mv');
  const info = document.getElementById('info');

  // Prove JS is running immediately
  info.textContent = 'JS_OK (initializing…)';

  function scrollFraction() {
    const max = document.documentElement.scrollHeight - window.innerHeight;
    if (max <= 0) return 0;
    return Math.min(1, Math.max(0, window.scrollY / max));
  }

  function diag(label='') {
    const r = mv.getBoundingClientRect();
    const dur = (mv && isFinite(mv.duration)) ? mv.duration : 0;
    const ct  = (mv && isFinite(mv.currentTime)) ? mv.currentTime : 0;
    const fr = scrollFraction();
    const rs = (typeof mv.readyState !== 'undefined') ? mv.readyState : 'n/a';
    info.textContent =
      `${label} mv=${Math.round(r.width)}x${Math.round(r.height)} ` +
      `ready=${rs} scroll=${fr.toFixed(3)} time=${ct.toFixed(3)}s dur=${dur.toFixed(3)}s`;
  }

  function scrub() {
    // Always update HUD
    diag('');

    // Only scrub if we actually have a duration
    if (!mv.duration || !isFinite(mv.duration) || mv.duration <= 0) return;
    const fr = scrollFraction();
    mv.currentTime = fr * mv.duration;
    diag('');
  }

  // Capture model-viewer errors explicitly
  mv.addEventListener('error', (e) => {
    const detail = (e && e.detail) ? JSON.stringify(e.detail) : '(no detail)';
    diag('ERROR ');
    console.log('model-viewer error:', e, e.detail);
    info.textContent += `  detail=${detail}`;
  });

  mv.addEventListener('load', () => {
    // FORCE_REFLOW_FIX: some browsers briefly create a 0x0 WebGL canvas; force layout + resize.
    setTimeout(() => {
      try {
        mv.style.display = 'none';
        void mv.offsetHeight; // force reflow
        mv.style.display = 'block';
        window.dispatchEvent(new Event('resize'));
      } catch (e) {}
    }, 50);

    requestAnimationFrame(() => window.dispatchEvent(new Event('resize')));

    // Pause so we can scrub deterministically (if animated)
    try { mv.pause(); } catch(e) {}
    scrub();
    window.addEventListener('scroll', scrub, { passive: true });
    window.addEventListener('resize', scrub, { passive: true });
  });

  // Even if "load" never fires, keep showing size/readyState
  setInterval(() => diag(''), 500);
  diag('JS_OK ');
</script>
</body>
</html>
